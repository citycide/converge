'use strict'

const axios = require('axios')
const Promise = require('bluebird')
const { resolve } = require('path')
const { install, prune } = require('pnpm')
const getPackageProps = require('npm-package-arg')

const {
  existsAsync,
  fileAsync,
  readAsync,
  writeAsync
} = require('fs-jetpack')

const log = require('../../logger')
const { paths } = require('../../constants')
const { name, version } = require('../../../package.json')

const directory = exports.directory = resolve(paths.data, 'plugins')
const packagePath = resolve(directory, 'package.json')
const manifestPath = resolve(directory, 'manifest.json')

let updating = false

exports.getPlugins = () => {
  return readManifest().then(({ plugins }) => plugins)
}

exports.getLocalPlugins = () => {
  return readManifest().then(({ localPlugins }) => localPlugins)
}

exports.update = context => {
  if (updating) {
    log.trace('plugin update already in progress')
    return Promise.resolve()
  }

  updating = true
  context.emit('plugins:update:start')

  return makePackage()
    .then(() => prune({ cwd: directory }))
    .then(() => install({ cwd: directory }))
    .then(() => {
      updating = false
      context.emit('plugins:update:done')
    })
    .catch(e => {
      updating = false
      // if (e.code === 'ENOENT') return null
      log.error(e)
    })
}

exports.addPlugin = (context, title) => {
  let { name, version } = getPackageProps(title)

  return Promise.all([isPackage(name), exports.getPlugins()])
    .then((exists, current) => {
      if (!exists) return false
      let index = current.indexOf(name)
      if (index >= 0) return false
      return true
    })
    .then(shouldAdd => {
      if (!shouldAdd) return
      return readAsync(manifestPath, 'json')
    })
    .then(manifest => {
      manifest = Object.assign({ plugins: [] }, manifest)

      let i = manifest.plugins.findIndex(v => {
        return v.split('@', 2)[0] === name
      })

      if (i >= 0) {
        manifest.plugins[i] = `${name}@${version}`
      } else {
        manifest.plugins.push(`${name}@${version}`)
      }

      return writeAsync(manifestPath, manifest)
    })
    .then(() => exports.update(context))
}

function makePackage () {
  return exports.getPlugins()
    .then(plugins => {
      return {
        name,
        version,
        description: 'Automatically generated by singularity-bot',
        private: true,
        license: 'MIT',
        repository: 'citycide/singularity',
        homepage: 'https://github.com/citycide/singularity',
        dependencies: makeDependencies(plugins)
      }
    })
    .then(pkg => writeAsync(packagePath, pkg))
}

function readManifest () {
  return existsAsync(manifestPath)
    .then(exists => {
      if (!exists) {
        return fileAsync(
          manifestPath,
          { content: { plugins: [], localPlugins: [] } }
        )
      }
    })
    .then(() => readAsync(manifestPath, 'json'))
    .catch(e => {
      log.error(e.message)
      return { plugins: [] }
    })
}

function makeDependencies (plugins) {
  return plugins.reduce((acc, plugin) => {
    try {
      let { name, spec } = getPackageProps(plugin)
      return Object.assign(acc, { [name]: spec })
    } catch (e) {
      log.error(`Invalid plugin ${plugin}`)
      return acc
    }
  }, {})
}

function isPackage (name) {
  if (!name || typeof name !== 'string') {
    return Promise.reject(new Error('invalid package name'))
  }

  let query = name.toLowerCase()
  return axios.head(`https://registry.npmjs.org/${query}`)
    .then(() => true)
    .catch(e => {
      if (e.response.status === 404) return false
      throw e
    })
}
